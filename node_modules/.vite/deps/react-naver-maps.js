import {
  require_react
} from "./chunk-YJVGYAW2.js";
import {
  __commonJS,
  __esm,
  __export,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-62VDRKYJ.js";

// node_modules/fbjs/lib/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/fbjs/lib/shallowEqual.js"(exports, module2) {
    "use strict";
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function is(x, y) {
      if (x === y) {
        return x !== 0 || y !== 0 || 1 / x === 1 / y;
      } else {
        return x !== x && y !== y;
      }
    }
    function shallowEqual2(objA, objB) {
      if (is(objA, objB)) {
        return true;
      }
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      for (var i = 0; i < keysA.length; i++) {
        if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
          return false;
        }
      }
      return true;
    }
    module2.exports = shallowEqual2;
  }
});

// node_modules/react-naver-maps/node_modules/recompose/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/react-naver-maps/node_modules/recompose/node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module2) {
    "use strict";
    var REACT_STATICS = {
      childContextTypes: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = getPrototypeOf && getPrototypeOf(Object);
    function hoistNonReactStatics2(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics2(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
        return targetComponent;
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics2;
  }
});

// node_modules/change-emitter/lib/index.js
var require_lib = __commonJS({
  "node_modules/change-emitter/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var createChangeEmitter2 = exports.createChangeEmitter = function createChangeEmitter3() {
      var currentListeners = [];
      var nextListeners = currentListeners;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      function listen(listener) {
        if (typeof listener !== "function") {
          throw new Error("Expected listener to be a function.");
        }
        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function() {
          if (!isSubscribed) {
            return;
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index2 = nextListeners.indexOf(listener);
          nextListeners.splice(index2, 1);
        };
      }
      function emit() {
        currentListeners = nextListeners;
        var listeners = currentListeners;
        for (var i = 0; i < listeners.length; i++) {
          listeners[i].apply(listeners, arguments);
        }
      }
      return {
        listen,
        emit
      };
    };
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root2.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index2 = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result2 = Array(length);
      while (++index2 < length) {
        result2[index2] = array[index2 + start];
      }
      return result2;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result2 = value + "";
      return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase2 = createCompounder(function(result2, word, index2) {
      word = word.toLowerCase();
      return result2 + (index2 ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase2;
  }
});

// node_modules/lodash.difference/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.difference/index.js"(exports, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index2 = -1, length = array ? array.length : 0;
      while (++index2 < length) {
        if (comparator(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array ? array.length : 0, result2 = Array(length);
      while (++index2 < length) {
        result2[index2] = iteratee(array[index2], index2, array);
      }
      return result2;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result2 = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result2 = !!(value + "");
        } catch (e) {
        }
      }
      return result2;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root2["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root2.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    var Map2 = getNative(root2, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result2 = data[key];
        return result2 === HASH_UNDEFINED ? void 0 : result2;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index2, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index2 = assocIndexOf(data, key);
      if (index2 < 0) {
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index2 = -1, includes = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values.length;
      if (!length) {
        return result2;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index2 < length) {
          var value = array[index2], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result2.push(value);
          } else if (!includes(values, computed, comparator)) {
            result2.push(value);
          }
        }
      return result2;
    }
    function baseFlatten(array, depth, predicate, isStrict, result2) {
      var index2 = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result2 || (result2 = []);
      while (++index2 < length) {
        var value = array[index2];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result2);
          } else {
            arrayPush(result2, value);
          }
        } else if (!isStrict) {
          result2[result2.length] = value;
        }
      }
      return result2;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index2 < length) {
          array[index2] = args[start + index2];
        }
        index2 = -1;
        var otherArgs = Array(start + 1);
        while (++index2 < start) {
          otherArgs[index2] = args[index2];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = difference;
  }
});

// node_modules/warning/warning.js
var require_warning = __commonJS({
  "node_modules/warning/warning.js"(exports, module2) {
    "use strict";
    var __DEV__ = true;
    var warning2 = function() {
    };
    if (__DEV__) {
      printWarning = function printWarning2(format, args) {
        var len = arguments.length;
        args = new Array(len > 1 ? len - 1 : 0);
        for (var key = 1; key < len; key++) {
          args[key - 1] = arguments[key];
        }
        var argIndex = 0;
        var message = "Warning: " + format.replace(/%s/g, function() {
          return args[argIndex++];
        });
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
      warning2 = function(condition, format, args) {
        var len = arguments.length;
        args = new Array(len > 2 ? len - 2 : 0);
        for (var key = 2; key < len; key++) {
          args[key - 2] = arguments[key];
        }
        if (format === void 0) {
          throw new Error(
            "`warning(condition, format, ...args)` requires a warning message argument"
          );
        }
        if (!condition) {
          printWarning.apply(null, [format].concat(args));
        }
      };
    }
    var printWarning;
    module2.exports = warning2;
  }
});

// node_modules/invariant/browser.js
var require_browser = __commonJS({
  "node_modules/invariant/browser.js"(exports, module2) {
    "use strict";
    var invariant3 = function(condition, format, a, b, c, d, e, f) {
      if (true) {
        if (format === void 0) {
          throw new Error("invariant requires an error message argument");
        }
      }
      if (!condition) {
        var error;
        if (format === void 0) {
          error = new Error(
            "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
          );
        } else {
          var args = [a, b, c, d, e, f];
          var argIndex = 0;
          error = new Error(
            format.replace(/%s/g, function() {
              return args[argIndex++];
            })
          );
          error.name = "Invariant Violation";
        }
        error.framesToPop = 1;
        throw error;
      }
    };
    module2.exports = invariant3;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module2) {
    module2.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module2) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module2) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var ResizeObserver_es_exports = {};
__export(ResizeObserver_es_exports, {
  default: () => ResizeObserver_es_default
});
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var MapShim, isBrowser, global$1, requestAnimationFrame$1, trailingTimeout, REFRESH_DELAY, transitionKeys, mutationObserverSupported, ResizeObserverController, defineConfigurable, getWindowOf, emptyRect, isSVGGraphicsElement, ResizeObservation, ResizeObserverEntry, ResizeObserverSPI, observers, ResizeObserver, index, ResizeObserver_es_default;
var init_ResizeObserver_es = __esm({
  "node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js"() {
    MapShim = function() {
      if (typeof Map !== "undefined") {
        return Map;
      }
      function getIndex(arr, key) {
        var result2 = -1;
        arr.some(function(entry, index2) {
          if (entry[0] === key) {
            result2 = index2;
            return true;
          }
          return false;
        });
        return result2;
      }
      return function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key) {
          var index2 = getIndex(this.__entries__, key);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key, value) {
          var index2 = getIndex(this.__entries__, key);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        class_1.prototype.delete = function(key) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key) {
          return !!~getIndex(this.__entries__, key);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
            var entry = _a[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }();
    }();
    isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
    global$1 = function() {
      if (typeof global !== "undefined" && global.Math === Math) {
        return global;
      }
      if (typeof self !== "undefined" && self.Math === Math) {
        return self;
      }
      if (typeof window !== "undefined" && window.Math === Math) {
        return window;
      }
      return Function("return this")();
    }();
    requestAnimationFrame$1 = function() {
      if (typeof requestAnimationFrame === "function") {
        return requestAnimationFrame.bind(global$1);
      }
      return function(callback) {
        return setTimeout(function() {
          return callback(Date.now());
        }, 1e3 / 60);
      };
    }();
    trailingTimeout = 2;
    REFRESH_DELAY = 20;
    transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
    mutationObserverSupported = typeof MutationObserver !== "undefined";
    ResizeObserverController = function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer) {
        if (!~this.observers_.indexOf(observer)) {
          this.observers_.push(observer);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer) {
          return observer.gatherActive(), observer.hasActive();
        });
        activeObservers.forEach(function(observer) {
          return observer.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }();
    defineConfigurable = function(target, props) {
      for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
          value: props[key],
          enumerable: false,
          writable: false,
          configurable: true
        });
      }
      return target;
    };
    getWindowOf = function(target) {
      var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
      return ownerGlobal || global$1;
    };
    emptyRect = createRectInit(0, 0, 0, 0);
    isSVGGraphicsElement = function() {
      if (typeof SVGGraphicsElement !== "undefined") {
        return function(target) {
          return target instanceof getWindowOf(target).SVGGraphicsElement;
        };
      }
      return function(target) {
        return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
      };
    }();
    ResizeObservation = function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }();
    ResizeObserverEntry = function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }();
    ResizeObserverSPI = function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }();
    observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
    ResizeObserver = function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
      }
      return ResizeObserver2;
    }();
    [
      "observe",
      "unobserve",
      "disconnect"
    ].forEach(function(method) {
      ResizeObserver.prototype[method] = function() {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
      };
    });
    index = function() {
      if (typeof global$1.ResizeObserver !== "undefined") {
        return global$1.ResizeObserver;
      }
      return ResizeObserver;
    }();
    ResizeObserver_es_default = index;
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root2.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result2 = func.apply(thisArg, args);
        return result2;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result2;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result2;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result2 : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result2;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = debounce2;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root2 = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root2.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result2 = func.apply(thisArg, args);
        return result2;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result2;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result3 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result3, maxWait - timeSinceLastInvoke) : result3;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result2;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result2 : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result2;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle2(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = throttle2;
  }
});

// node_modules/react-naver-maps/node_modules/react-resize-detector/lib/components/ResizeDetector.js
var require_ResizeDetector = __commonJS({
  "node_modules/react-naver-maps/node_modules/react-resize-detector/lib/components/ResizeDetector.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _createClass2 = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    var _propTypes = require_prop_types();
    var _propTypes2 = _interopRequireDefault(_propTypes);
    var _resizeObserverPolyfill = (init_ResizeObserver_es(), __toCommonJS(ResizeObserver_es_exports));
    var _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);
    var _lodash = require_lodash3();
    var _lodash2 = _interopRequireDefault(_lodash);
    var _lodash3 = require_lodash4();
    var _lodash4 = _interopRequireDefault(_lodash3);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck2(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn2(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits2(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var listMode = { debounce: _lodash2.default, throttle: _lodash4.default };
    var styles = {
      position: "absolute",
      width: 0,
      height: 0,
      visibility: "hidden",
      display: "none"
    };
    var ResizeDetector2 = function(_PureComponent) {
      _inherits2(ResizeDetector3, _PureComponent);
      function ResizeDetector3(props) {
        _classCallCheck2(this, ResizeDetector3);
        var _this = _possibleConstructorReturn2(this, (ResizeDetector3.__proto__ || Object.getPrototypeOf(ResizeDetector3)).call(this, props));
        _this.createResizeObserver = function(entries) {
          var _this$props = _this.props, handleWidth = _this$props.handleWidth, handleHeight = _this$props.handleHeight, onResize = _this$props.onResize;
          entries.forEach(function(entry) {
            var _entry$contentRect = entry.contentRect, width = _entry$contentRect.width, height = _entry$contentRect.height;
            var notifyWidth = handleWidth && _this.width !== width;
            var notifyHeight = handleHeight && _this.height !== height;
            if (!_this.skipOnMount && (notifyWidth || notifyHeight)) {
              onResize(width, height);
            }
            _this.width = width;
            _this.height = height;
            _this.skipOnMount = false;
          });
        };
        var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, refreshRate = props.refreshRate;
        _this.width = void 0;
        _this.height = void 0;
        _this.skipOnMount = skipOnMount;
        var resizeObserver = listMode[refreshMode] && listMode[refreshMode](_this.createResizeObserver, refreshRate) || _this.createResizeObserver;
        _this.ro = new _resizeObserverPolyfill2.default(resizeObserver);
        return _this;
      }
      _createClass2(ResizeDetector3, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var resizableElementId = this.props.resizableElementId;
          var resizableElement = resizableElementId ? document.getElementById(resizableElementId) : this.el.parentElement;
          this.ro.observe(resizableElement);
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          var resizableElementId = this.props.resizableElementId;
          var resizableElement = resizableElementId ? document.getElementById(resizableElementId) : this.el.parentElement;
          this.ro.unobserve(resizableElement);
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          return _react2.default.createElement("div", {
            style: styles,
            ref: function ref(el) {
              _this2.el = el;
            }
          });
        }
      }]);
      return ResizeDetector3;
    }(_react.PureComponent);
    exports.default = ResizeDetector2;
    ResizeDetector2.propTypes = {
      handleWidth: _propTypes2.default.bool,
      handleHeight: _propTypes2.default.bool,
      skipOnMount: _propTypes2.default.bool,
      refreshRate: _propTypes2.default.number,
      refreshMode: _propTypes2.default.string,
      resizableElementId: _propTypes2.default.string,
      onResize: _propTypes2.default.func
    };
    ResizeDetector2.defaultProps = {
      handleWidth: false,
      handleHeight: false,
      skipOnMount: false,
      refreshRate: 1e3,
      refreshMode: void 0,
      resizableElementId: "",
      onResize: function onResize(e) {
        return e;
      }
    };
  }
});

// node_modules/react-naver-maps/node_modules/react-resize-detector/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-naver-maps/node_modules/react-resize-detector/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _ResizeDetector = require_ResizeDetector();
    var _ResizeDetector2 = _interopRequireDefault(_ResizeDetector);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = _ResizeDetector2.default;
  }
});

// node_modules/load-js/index.js
var require_load_js = __commonJS({
  "node_modules/load-js/index.js"(exports, module2) {
    !function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        ("undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this).loadJS = e();
      }
    }(function() {
      return __require = _bb$iter = function(e, r) {
        var t = {};
        function n(r2) {
          if (!t.hasOwnProperty(r2)) {
            var a2 = { exports: {} }, i2 = e[r2][0], u = e[r2][1];
            t[r2] = a2.exports, i2((d = u, function(e2) {
              var r3 = d[e2];
              if (o(r3))
                return n(r3);
              for (var t2 = n.next; t2; t2 = t2.next)
                if (t2.has(r3))
                  return t2.get(r3);
              for (var a3 = n.prev; a3; a3 = a3.prev)
                if (a3.has(r3))
                  return a3.get(r3);
              throw new Error("Module '" + e2 + "' with id " + r3 + " was not found");
            }), a2, a2.exports), t[r2] = a2.exports;
          }
          var d;
          return t[r2];
        }
        function o(r2) {
          return e[r2];
        }
        if (n.get = n, n.has = o, n.next = "undefined" == typeof _bb$iter ? null : _bb$iter, r.length)
          for (var a = n, i = n.next; i; )
            i.prev = a, a = i, i = i.next;
        return r.forEach(n), n;
      }({ 1: [function(e, r, t) {
        function n() {
          var e2 = {}, r2 = document.getElementsByTagName("head")[0] || document.documentElement;
          function t2(t3) {
            "string" == typeof t3 && (t3 = { url: t3 });
            var n2 = t3.id || t3.url, o = e2[n2];
            if (o)
              return console.log("load-js: cache hit", n2), o;
            if (false !== t3.allowExternal) {
              var a = function(e3) {
                var r3 = e3 && document.getElementById(e3);
                if (r3 && "watermark" !== r3.loadJS)
                  return console.warn("load-js: duplicate script with id:", e3), r3;
              }(t3.id) || function(e3) {
                var r3 = e3 && document.querySelector("script[src='" + e3 + "']");
                if (r3 && "watermark" !== r3.loadJS)
                  return console.warn("load-js: duplicate script with url:", e3), r3;
              }(t3.url);
              if (a) {
                var i = Promise.resolve(a);
                return n2 && (e2[n2] = i), i;
              }
            }
            if (!t3.url && !t3.text)
              throw new Error("load-js: must provide a url or text to load");
            var u = (t3.url ? function(e3, r3) {
              return new Promise(function(t4, n3) {
                var o2 = false;
                r3.onload = r3.onreadystatechange = function() {
                  o2 || r3.readyState && "loaded" !== r3.readyState && "complete" !== r3.readyState || (o2 = true, r3.onload = r3.onreadystatechange = null, t4(r3));
                }, r3.onerror = n3, e3.appendChild(r3);
              });
            } : function(e3, r3) {
              return e3.appendChild(r3), Promise.resolve(r3);
            })(r2, function(e3) {
              var r3 = document.createElement("script");
              r3.charset = e3.charset || "utf-8", r3.type = e3.type || "text/javascript", r3.async = !!e3.async, r3.id = e3.id || e3.url, r3.loadJS = "watermark", e3.url && (r3.src = e3.url);
              e3.text && (r3.text = e3.text);
              return r3;
            }(t3));
            return n2 && false !== t3.cache && (e2[n2] = u), u;
          }
          return function(e3) {
            return e3 instanceof Array ? Promise.all(e3.map(t2)) : t2(e3);
          };
        }
        r.exports = n(), r.exports.create = n;
      }, {}] }, [1]), _bb$iter(1);
    });
  }
});

// node_modules/react-naver-maps/dist/hocs-18b20544.js
var import_react2 = __toESM(require_react());

// node_modules/react-naver-maps/node_modules/recompose/es/Recompose.js
var import_react = __toESM(require_react());
var import_shallowEqual = __toESM(require_shallowEqual());
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_change_emitter = __toESM(require_lib());

// node_modules/symbol-observable/es/ponyfill.js
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      result2 = Symbol2("observable");
      Symbol2.observable = result2;
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}

// node_modules/symbol-observable/es/index.js
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
var result = symbolObservablePonyfill(root);
var es_default = result;

// node_modules/react-naver-maps/node_modules/recompose/es/Recompose.js
var getDisplayName = function getDisplayName2(Component$$1) {
  if (typeof Component$$1 === "string") {
    return Component$$1;
  }
  if (!Component$$1) {
    return void 0;
  }
  return Component$$1.displayName || Component$$1.name || "Component";
};
var wrapDisplayName = function wrapDisplayName2(BaseComponent, hocName) {
  return hocName + "(" + getDisplayName(BaseComponent) + ")";
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
};
var Nothing = function(_Component) {
  inherits(Nothing2, _Component);
  function Nothing2() {
    classCallCheck(this, Nothing2);
    return possibleConstructorReturn(this, _Component.apply(this, arguments));
  }
  Nothing2.prototype.render = function render() {
    return null;
  };
  return Nothing2;
}(import_react.Component);
function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a, b) {
    return function() {
      return a(b.apply(void 0, arguments));
    };
  });
}
var _config = {
  fromESObservable: null,
  toESObservable: null
};
var config = {
  fromESObservable: function fromESObservable(observable) {
    return typeof _config.fromESObservable === "function" ? _config.fromESObservable(observable) : observable;
  },
  toESObservable: function toESObservable(stream) {
    return typeof _config.toESObservable === "function" ? _config.toESObservable(stream) : stream;
  }
};
var createEventHandlerWithConfig = function createEventHandlerWithConfig2(config$$1) {
  return function() {
    var _config$fromESObserva;
    var emitter = (0, import_change_emitter.createChangeEmitter)();
    var stream = config$$1.fromESObservable((_config$fromESObserva = {
      subscribe: function subscribe(observer) {
        var unsubscribe = emitter.listen(function(value) {
          return observer.next(value);
        });
        return { unsubscribe };
      }
    }, _config$fromESObserva[es_default] = function() {
      return this;
    }, _config$fromESObserva));
    return {
      handler: emitter.emit,
      stream
    };
  };
};
var createEventHandler = createEventHandlerWithConfig(config);

// node_modules/react-naver-maps/dist/hocs-18b20544.js
var import_lodash = __toESM(require_lodash());
var import_lodash2 = __toESM(require_lodash2());
var import_warning = __toESM(require_warning());
var import_invariant = __toESM(require_browser());
var import_react_resize_detector = __toESM(require_lib2());
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}
function _asyncToGenerator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
var pick = function pick2(keys) {
  return function(props) {
    return keys.reduce(function(ret, key) {
      if (props[key] !== void 0) {
        ret[key] = props[key];
      }
      return ret;
    }, {});
  };
};
function generageEventLookup(naverEventNames) {
  return naverEventNames.reduce(function(ret, eventName) {
    var propsListenerName = (0, import_lodash.default)("on_".concat(eventName));
    return _objectSpread({}, ret, _defineProperty({}, propsListenerName, eventName));
  }, {});
}
var bridgeEventHandlers = function bridgeEventHandlers2(WrappedComponent) {
  var Wrapper = function(_React$Component) {
    _inherits(Wrapper2, _React$Component);
    function Wrapper2(props) {
      var _this;
      _classCallCheck(this, Wrapper2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Wrapper2).call(this, props));
      _this.naverListeners = {};
      _this.naverEventLookup = {};
      _this.handlingPropNames = [];
      _this.registerEventInstance = _this.registerEventInstance.bind(_assertThisInitialized(_assertThisInitialized(_this)));
      return _this;
    }
    _createClass(Wrapper2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.updateListeners();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateListeners();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        var _this2 = this;
        Object.values(this.naverListeners).forEach(function(listener) {
          _this2.unlisten(listener);
        });
      }
    }, {
      key: "getEventByHandlerName",
      value: function getEventByHandlerName(handlerName) {
        return this.naverEventLookup[handlerName];
      }
    }, {
      key: "registerEventInstance",
      value: function registerEventInstance(instance) {
        (0, import_warning.default)(!this.instance, "react-naver-maps: bridgeEventHandlers - Tried to Change instance.");
        (0, import_invariant.default)(instance, "react-naver-maps: bridgeEventHandlers - required naver instance, but ".concat(instance));
        this.instance = instance;
        if (this.props.registerEventInstance)
          this.props.registerEventInstance(instance);
      }
    }, {
      key: "updateListeners",
      value: function updateListeners() {
        var _this3 = this;
        var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
        if (this.eventsCache !== props.events) {
          this.eventsCache = props.events;
          this.naverEventLookup = generageEventLookup(props.events);
          this.handlingPropNames = Object.keys(this.naverEventLookup);
        }
        var prevNaverListeners = this.naverListeners;
        this.naverListeners = {};
        var orphans = {};
        var updateds = {};
        this.handlingPropNames.forEach(function(propName) {
          var handler = props[propName];
          if (prevNaverListeners[propName]) {
            var prevNaverListener = prevNaverListeners[propName];
            var prevHandler = prevNaverListener.listener;
            if (prevHandler === handler) {
              _this3.naverListeners[propName] = prevNaverListeners[propName];
            } else {
              orphans[propName] = prevNaverListener;
              updateds[propName] = handler;
            }
          } else if (handler) {
            updateds[propName] = handler;
          }
        });
        Object.keys(updateds).forEach(function(updatedPropName) {
          var evt = _this3.getEventByHandlerName(updatedPropName);
          _this3.naverListeners[updatedPropName] = _this3.listen(evt, updateds[updatedPropName]);
        });
        Object.values(orphans).forEach(function(orphan) {
          _this3.unlisten(orphan);
        });
      }
    }, {
      key: "listen",
      value: function listen(eventName, listener) {
        var navermaps = this.props.navermaps;
        (0, import_invariant.default)(navermaps, "props.navermaps required");
        (0, import_invariant.default)(this.instance, "may be forgot to call registerEventInstance");
        return navermaps.Event.addListener(this.instance, eventName, listener);
      }
    }, {
      key: "unlisten",
      value: function unlisten(listener) {
        var navermaps = this.props.navermaps;
        navermaps.Event.removeListener(listener);
      }
    }, {
      key: "render",
      value: function render() {
        return import_react2.default.createElement(WrappedComponent, _extends({}, this.props, {
          registerEventInstance: this.registerEventInstance
        }));
      }
    }]);
    return Wrapper2;
  }(import_react2.default.Component);
  Wrapper.displayName = wrapDisplayName(WrappedComponent, "bridgeEventHandlers");
  return Wrapper;
};
var withNavermaps = function withNavermaps2(WrappedComponent) {
  var Navermaps = function(_React$Component) {
    _inherits(Navermaps2, _React$Component);
    function Navermaps2(props) {
      var _this;
      _classCallCheck(this, Navermaps2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Navermaps2).call(this, props));
      var navermaps = _this.getNavermaps();
      (0, import_invariant.default)(navermaps, "props.navermaps or window.naver.maps is required.");
      return _this;
    }
    _createClass(Navermaps2, [{
      key: "getNavermaps",
      value: function getNavermaps() {
        return this.props.navermaps || window.naver && window.naver.maps;
      }
    }, {
      key: "render",
      value: function render() {
        var navermaps = this.getNavermaps();
        return import_react2.default.createElement(WrappedComponent, _extends({}, this.props, {
          navermaps
        }));
      }
    }]);
    return Navermaps2;
  }(import_react2.default.Component);
  Navermaps.displayName = wrapDisplayName(WrappedComponent, "withNavermaps");
  return Navermaps;
};
var injectNaverRef = function injectNaverRef2(WrappedComponent) {
  function Wrapper(_ref) {
    var naverRef = _ref.naverRef, restProps = _objectWithoutProperties(_ref, ["naverRef"]);
    return import_react2.default.createElement(WrappedComponent, _extends({}, restProps, {
      ref: naverRef
    }));
  }
  Wrapper.displayName = wrapDisplayName(WrappedComponent, "injectNaverRef");
  return Wrapper;
};

// node_modules/react-naver-maps/dist/react-naver-maps.esm.js
var import_react3 = __toESM(require_react());
var import_lodash3 = __toESM(require_lodash3());
var import_invariant2 = __toESM(require_browser());
var import_prop_types = __toESM(require_prop_types());
var import_load_js = __toESM(require_load_js());
var import_lodash4 = __toESM(require_lodash());
var import_lodash5 = __toESM(require_lodash2());
var import_warning2 = __toESM(require_warning());
var import_react_resize_detector2 = __toESM(require_lib2());
var mapOptionKeys = ["background", "baseTileOpacity", "disableDoubleClickZoom", "disableDoubleTapZoom", "disableKineticPan", "disableTwoFingerTapZoom", "draggable", "keyboardShortcuts", "logoControl", "logoControlOptions", "mapDataControl", "mapDataControlOptions", "mapTypeControl", "mapTypeControlOptions", "mapTypes", "maxBounds", "maxZoom", "minZoom", "padding", "pinchZoom", "resizeOrigin", "scaleControl", "scaleControlOptions", "scrollWheel", "overlayZoomEffect", "tileSpare", "tileTransition", "zoomControl", "zoomControlOptions", "zoomOrigin"];
var kvoKeys = ["mapType", "mapTypeId", "size", "bounds", "center", "centerPoint", "projection", "zoom"];
var defaultKVOKeyMap = {
  defaultMapType: "mapType",
  defaultMapTypeId: "mapTypeId",
  defaultSize: "size",
  defaultBounds: "bounds",
  defaultCenter: "center",
  defaultCenterPoint: "centerPoint",
  defaultProjection: "projection",
  defaultZoom: "zoom"
};
var defaultKVOKeys = kvoKeys.map(function(key) {
  return "default" + key[0].toUpperCase() + key.substring(1, key.length);
});
var pickMapOptions = pick(mapOptionKeys);
var pickKVOOptions = pick(kvoKeys);
var pickDefaultKVOKeys = pick(defaultKVOKeys);
var withNaverMapInstance = function withNaverMapInstance2(WrappedComponent) {
  var Wrapper = function(_Component) {
    _inherits(Wrapper2, _Component);
    function Wrapper2(props) {
      var _this;
      _classCallCheck(this, Wrapper2);
      _this = _possibleConstructorReturn(this, _getPrototypeOf(Wrapper2).call(this, props));
      _this.lazyUpdateKVO = (0, import_lodash3.default)(_this.lazyUpdateKVO, 0);
      return _this;
    }
    _createClass(Wrapper2, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.instance) {
          this.instance.destroy();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.createMap();
        this.forceUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateMap();
      }
    }, {
      key: "lazyUpdateKVO",
      value: function() {
        var _lazyUpdateKVO = _asyncToGenerator(function* (_ref) {
          var zoom = _ref.zoom, center = _ref.center, bounds = _ref.bounds, size = _ref.size;
          if (this.break) {
            this.break = false;
            return;
          }
          var shouldUpdateZoom = zoom && this.map.getZoom() !== zoom;
          var shouldUpdateCenter = center && !this.map.getCenter().equals(center);
          var shouldUpdateBounds = bounds && !this.map.getBounds().equals(bounds);
          var shouldUpdateSize = size && !this.map.getSize().equals(size);
          var transitionOptions = this.props.transitionOptions;
          if (shouldUpdateZoom && shouldUpdateCenter) {
            this.updating = true;
            this.map.morph(center, zoom, transitionOptions);
          } else {
            if (shouldUpdateCenter) {
              this.updating = true;
              this.map.panTo(center, transitionOptions);
            }
            if (shouldUpdateZoom) {
              this.updating = true;
              this.map.setZoom(zoom);
            }
          }
          if (shouldUpdateSize) {
            this.map.setSize(size);
          }
        });
        return function lazyUpdateKVO(_x) {
          return _lazyUpdateKVO.apply(this, arguments);
        };
      }()
    }, {
      key: "updateMap",
      value: function updateMap() {
        var _this$props = this.props, zoom = _this$props.zoom, center = _this$props.center, bounds = _this$props.bounds, size = _this$props.size, mapTypeId = _this$props.mapTypeId, projection = _this$props.projection;
        if (center && center.force || bounds && bounds.force) {
          this.updating = false;
        }
        if (this.updating) {
          return;
        }
        this.lazyUpdateKVO({
          zoom,
          center,
          bounds,
          size
        });
        var shouldUpdateMapTypeId = mapTypeId && this.map.getMapTypeId() !== mapTypeId;
        if (shouldUpdateMapTypeId) {
          this.map.setMapTypeId(mapTypeId);
        }
        var shouldUpdateProjection = projection && this.map.getProjection() !== projection;
        if (shouldUpdateProjection) {
          this.map.setProjection(projection);
        }
        var mapOptions = pickMapOptions(this.props);
        this.map.setOptions(_objectSpread({}, mapOptions));
      }
    }, {
      key: "createMap",
      value: function createMap() {
        var _this2 = this;
        var _this$props2 = this.props, navermaps = _this$props2.navermaps, id = _this$props2.id;
        (0, import_invariant2.default)(id, "react-naver-maps: <Map /> - props.id is required");
        var mapOptions = pickMapOptions(this.props);
        var kvoOptions = pickKVOOptions(this.props);
        var defaultKVOOptions = pickDefaultKVOKeys(this.props);
        var allMapOptions = _objectSpread({}, mapOptions, kvoOptions);
        Object.keys(defaultKVOOptions).forEach(function(defaultKey) {
          allMapOptions[defaultKVOKeyMap[defaultKey]] = defaultKVOOptions[defaultKey];
        });
        try {
          this.instance = new navermaps.Map(id, allMapOptions);
        } catch (e) {
          (0, import_invariant2.default)(false, "react-naver-maps: <Map /> - please check <div id=#".concat(id, "> is correctly mounted"));
        }
        this.map = this.instance;
        this.map.addListener("idle", function() {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener("zooming", function() {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener("mousedown", function() {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener("dragstart", function() {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener("pinchstart", function() {
          _this2.updating = false;
          _this2.break = true;
        });
        this.props.registerEventInstance(this.map);
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;
        var _this$props3 = this.props, children = _this$props3.children, restProps = _objectWithoutProperties(_this$props3, ["children"]);
        return import_react3.default.createElement(WrappedComponent, restProps, this.map && import_react3.default.Children.map(children, function(child) {
          if (child) {
            return import_react3.default.createElement(child.type, _extends({}, child.props, {
              map: _this3.map
            }));
          }
          return child;
        }));
      }
    }]);
    return Wrapper2;
  }(import_react3.Component);
  Wrapper.displayName = wrapDisplayName(WrappedComponent, "withNaverMapInstance");
  return Wrapper;
};
function NaverMapDom(_ref) {
  var id = _ref.id, style = _ref.style, className = _ref.className, children = _ref.children;
  return import_react3.default.createElement("div", {
    id,
    className,
    style
  }, children);
}
var ComposedMap = compose(
  withNavermaps,
  bridgeEventHandlers,
  injectNaverRef,
  withNaverMapInstance
)(NaverMapDom);
function NaverMap(props) {
  return import_react3.default.createElement(ComposedMap, props);
}
NaverMap.propTypes = {
  id: import_prop_types.default.string,
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  style: import_prop_types.default.object
};
NaverMap.defaultProps = {
  events: ["addLayer", "click", "dblclick", "doubletap", "drag", "dragend", "dragstart", "idle", "keydown", "keyup", "longtap", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "panning", "pinch", "pinchend", "pinchstart", "removeLayer", "resize", "rightclick", "tap", "tilesloaded", "touchend", "touchmove", "touchstart", "twofingertap", "zooming", "mapType_changed", "mapTypeId_changed", "size_changed", "bounds_changed", "center_changed", "centerPoint_changed", "projection_changed", "zoom_changed"],
  id: "react-naver-map"
};
var Overlay = function(_React$Component) {
  _inherits(Overlay2, _React$Component);
  function Overlay2() {
    _classCallCheck(this, Overlay2);
    return _possibleConstructorReturn(this, _getPrototypeOf(Overlay2).apply(this, arguments));
  }
  _createClass(Overlay2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.overlay)
        this.overlay.setMap(null);
    }
  }, {
    key: "createOverlay",
    value: function createOverlay() {
      var _this$props = this.props, OverlayView = _this$props.OverlayView, map = _this$props.map, registerEventInstance = _this$props.registerEventInstance;
      var overlay = new OverlayView({
        map
      });
      registerEventInstance(overlay);
      return overlay;
    }
  }, {
    key: "updateOverlay",
    value: function updateOverlay(overlay) {
      var overlayOptions = this.props.pickOverlayOptions(this.props);
      overlay.setOptions(overlayOptions);
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.overlay) {
        this.overlay = this.createOverlay();
      }
      this.updateOverlay(this.overlay);
      return null;
    }
  }]);
  return Overlay2;
}(import_react3.default.Component);
var Overlay$1 = bridgeEventHandlers(Overlay);
var pickCircleOptions = pick(["center", "radius", "strokeWeight", "strokeOpacity", "strokeColor", "strokeStyle", "strokeLineCap", "strokeLineJoin", "fillColor", "fillOpacity", "clickable", "visible", "zIndex"]);
function Circle(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Circle,
    pickOverlayOptions: pickCircleOptions
  }));
}
Circle.defaultProps = {
  events: ["center_changed", "click", "clickable_changed", "dblclick", "mousedown", "mouseout", "mouseover", "mouseup", "radius_changed", "visible_changed", "zIndex_changed"],
  radius: 0,
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: "#007EEA",
  strokeStyle: "solid",
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  fillColor: "none",
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Circle.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  center: import_prop_types.default.object.isRequired,
  radius: import_prop_types.default.number,
  strokeWeight: import_prop_types.default.number,
  strokeOpacity: import_prop_types.default.number,
  strokeColor: import_prop_types.default.string,
  strokeStyle: import_prop_types.default.string,
  strokeLineCap: import_prop_types.default.string,
  strokeLineJoin: import_prop_types.default.string,
  fillColor: import_prop_types.default.string,
  fillOpacity: import_prop_types.default.number,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number
};
var Circle$1 = withNavermaps(Circle);
var pickEllipseOptions = pick(["bounds", "strokeWeight", "strokeOpacity", "strokeColor", "strokeStyle", "strokeLineCap", "strokeLineJoin", "fillColor", "fillOpacity", "clickable", "visible", "zIndex"]);
function Ellipse(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Ellipse,
    pickOverlayOptions: pickEllipseOptions
  }));
}
Ellipse.defaultProps = {
  events: ["bounds_changed", "click", "clickable_changed", "dblclick", "mousedown", "mouseout", "mouseover", "mouseup", "visible_changed", "zIndex_changed"],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: "#007EEA",
  strokeStyle: "solid",
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  fillColor: "none",
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Ellipse.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  bounds: import_prop_types.default.object.isRequired,
  strokeWeight: import_prop_types.default.number,
  strokeOpacity: import_prop_types.default.number,
  strokeColor: import_prop_types.default.string,
  strokeStyle: import_prop_types.default.string,
  strokeLineCap: import_prop_types.default.string,
  strokeLineJoin: import_prop_types.default.string,
  fillColor: import_prop_types.default.string,
  fillOpacity: import_prop_types.default.number,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number
};
var Ellipse$1 = withNavermaps(Ellipse);
var GroundOverlay = function(_React$Component) {
  _inherits(GroundOverlay2, _React$Component);
  function GroundOverlay2() {
    _classCallCheck(this, GroundOverlay2);
    return _possibleConstructorReturn(this, _getPrototypeOf(GroundOverlay2).apply(this, arguments));
  }
  _createClass(GroundOverlay2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.overlay)
        this.overlay.setMap(null);
    }
  }, {
    key: "createGroundOverlay",
    value: function createGroundOverlay() {
      var _this$props = this.props, navermaps = _this$props.navermaps, map = _this$props.map, bounds = _this$props.bounds, url = _this$props.url, clickable = _this$props.clickable, registerEventInstance = _this$props.registerEventInstance;
      var groundOverlay = new navermaps.GroundOverlay(url, bounds, {
        map,
        clickable
      });
      registerEventInstance(groundOverlay);
      return groundOverlay;
    }
  }, {
    key: "updateGroundOverlay",
    value: function updateGroundOverlay(groundOverlay) {
      var opacity = this.props.opacity;
      groundOverlay.setOpacity(opacity);
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.overlay) {
        this.overlay = this.createGroundOverlay();
      }
      this.updateGroundOverlay(this.overlay);
      return null;
    }
  }]);
  return GroundOverlay2;
}(import_react3.default.Component);
GroundOverlay.defaultProps = {
  events: ["click", "dblclick"]
};
GroundOverlay.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  bounds: import_prop_types.default.object.isRequired,
  url: import_prop_types.default.string.isRequired,
  clickable: import_prop_types.default.bool,
  opacity: import_prop_types.default.number
};
var GroundOverlay$1 = compose(withNavermaps, bridgeEventHandlers)(GroundOverlay);
var pickMarkerOptions = pick(["position", "animation", "icon", "shape", "title", "cursor", "clickable", "draggable", "visible", "zIndex"]);
function Marker(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Marker,
    pickOverlayOptions: pickMarkerOptions
  }));
}
Marker.defaultProps = {
  events: ["animation_changed", "click", "clickable_changed", "dblclick", "draggable_changed", "icon_changed", "mousedown", "mouseout", "mouseover", "mouseup", "position_changed", "shape_changed", "title_changed", "visible_changed", "zIndex_changed"],
  title: null,
  cursor: "pointer",
  clickable: true,
  draggable: false,
  visible: true
};
Marker.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  position: import_prop_types.default.any.isRequired,
  animation: import_prop_types.default.number,
  icon: import_prop_types.default.any,
  shape: import_prop_types.default.object,
  title: import_prop_types.default.string,
  cursor: import_prop_types.default.string,
  draggable: import_prop_types.default.bool,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number
};
var Marker$1 = withNavermaps(Marker);
var pickPolygonOptions = pick(["paths", "strokeWeight", "strokeOpacity", "strokeColor", "strokeStyle", "strokeLineCap", "strokeLineJoin", "fillColor", "fillOpacity", "clickable", "visible", "zIndex"]);
function Polygon(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Polygon,
    pickOverlayOptions: pickPolygonOptions
  }));
}
Polygon.defaultProps = {
  events: ["click", "clickable_changed", "dblclick", "mousedown", "mouseout", "mouseover", "mouseup", "visible_changed", "zIndex_changed"],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: "#007EEA",
  strokeStyle: "solid",
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  fillColor: "none",
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Polygon.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  paths: import_prop_types.default.any.isRequired,
  strokeWeight: import_prop_types.default.number,
  strokeOpacity: import_prop_types.default.number,
  strokeColor: import_prop_types.default.string,
  strokeStyle: import_prop_types.default.string,
  strokeLineCap: import_prop_types.default.string,
  strokeLineJoin: import_prop_types.default.string,
  fillColor: import_prop_types.default.string,
  fillOpacity: import_prop_types.default.number,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number
};
var Polygon$1 = withNavermaps(Polygon);
var pickPolylineOptions = pick(["path", "strokeWeight", "strokeOpacity", "strokeColor", "strokeStyle", "strokeLineCap", "strokeLineJoin", "clickable", "visible", "zIndex", "startIcon", "startIconSize", "endIcon", "endIconSize"]);
function Polyline(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Polyline,
    pickOverlayOptions: pickPolylineOptions
  }));
}
Polyline.defaultProps = {
  events: ["click", "clickable_changed", "dblclick", "mousedown", "mouseout", "mouseover", "mouseup", "visible_changed", "zIndex_changed"],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: "#007EEA",
  strokeStyle: "solid",
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  clickable: false,
  visible: true,
  zIndex: 0
};
Polyline.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  path: import_prop_types.default.any.isRequired,
  strokeWeight: import_prop_types.default.number,
  strokeOpacity: import_prop_types.default.number,
  strokeColor: import_prop_types.default.string,
  strokeStyle: import_prop_types.default.string,
  strokeLineCap: import_prop_types.default.string,
  strokeLineJoin: import_prop_types.default.string,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number,
  startIcon: import_prop_types.default.number,
  startIconSize: import_prop_types.default.number,
  endIcon: import_prop_types.default.number,
  endIconSize: import_prop_types.default.number
};
var Polyline$1 = withNavermaps(Polyline);
var pickRectangleOptions = pick(["bounds", "strokeWeight", "strokeOpacity", "strokeColor", "strokeStyle", "strokeLineCap", "strokeLineJoin", "fillColor", "fillOpacity", "clickable", "visible", "zIndex"]);
function Rectangle(props) {
  return import_react3.default.createElement(Overlay$1, _extends({}, props, {
    OverlayView: props.navermaps.Rectangle,
    pickOverlayOptions: pickRectangleOptions
  }));
}
Rectangle.defaultProps = {
  events: ["bounds_changed", "click", "clickable_changed", "dblclick", "mousedown", "mouseout", "mouseover", "mouseup", "visible_changed", "zIndex_changed"],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: "#007EEA",
  strokeStyle: "solid",
  strokeLineCap: "butt",
  strokeLineJoin: "miter",
  fillColor: "none",
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Rectangle.propTypes = {
  events: import_prop_types.default.arrayOf(import_prop_types.default.string),
  bounds: import_prop_types.default.object.isRequired,
  strokeWeight: import_prop_types.default.number,
  strokeOpacity: import_prop_types.default.number,
  strokeColor: import_prop_types.default.string,
  strokeStyle: import_prop_types.default.string,
  strokeLineCap: import_prop_types.default.string,
  strokeLineJoin: import_prop_types.default.string,
  fillColor: import_prop_types.default.string,
  fillOpacity: import_prop_types.default.number,
  clickable: import_prop_types.default.bool,
  visible: import_prop_types.default.bool,
  zIndex: import_prop_types.default.number
};
var Rectangle$1 = withNavermaps(Rectangle);
var _loadNavermapsScript = function _loadNavermapsScript2(_ref) {
  var clientId = _ref.clientId, submodules = _ref.submodules, ncpClientId = _ref.ncpClientId;
  (0, import_invariant2.default)(clientId || ncpClientId, "clientId or ncpClientId is required");
  var requestUrl = "https://openapi.map.naver.com/openapi/v3/maps.js";
  if (clientId) {
    requestUrl += "?clientId=".concat(clientId);
  } else if (ncpClientId) {
    requestUrl += "?ncpClientId=".concat(ncpClientId);
  }
  if (submodules) {
    requestUrl += "&submodules=".concat(submodules.join(","));
  }
  return (0, import_load_js.default)(requestUrl).then(function() {
    var navermaps = window.naver.maps;
    if (navermaps.jsContentLoaded) {
      return navermaps;
    }
    var loadingJsContent = new Promise(function(resolve) {
      navermaps.onJSContentLoaded = function() {
        resolve(navermaps);
      };
    });
    return loadingJsContent;
  });
};
var loadScriptPromise = null;
var loadNavermapsScript = function loadNavermapsScript2(_ref2) {
  var clientId = _ref2.clientId, submodules = _ref2.submodules, ncpClientId = _ref2.ncpClientId;
  (0, import_invariant2.default)(clientId, "loadNavermapsScript: clientId is required");
  if (loadScriptPromise) {
    return loadScriptPromise;
  }
  loadScriptPromise = _loadNavermapsScript({
    clientId,
    ncpClientId,
    submodules
  });
  return loadScriptPromise;
};
var RenderAfterNavermapsLoaded = function(_React$Component) {
  _inherits(RenderAfterNavermapsLoaded2, _React$Component);
  function RenderAfterNavermapsLoaded2(props) {
    var _this;
    _classCallCheck(this, RenderAfterNavermapsLoaded2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(RenderAfterNavermapsLoaded2).call(this, props));
    _this.state = {
      loading: true
    };
    return _this;
  }
  _createClass(RenderAfterNavermapsLoaded2, [{
    key: "render",
    value: function render() {
      if (this.state.loading) {
        return this.props.loading;
      }
      if (this.state.error) {
        return this.props.error;
      }
      return this.props.children;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;
      var _this$props = this.props, clientId = _this$props.clientId, submodules = _this$props.submodules;
      loadNavermapsScript({
        clientId,
        submodules
      }).then(function() {
        _this2.setState({
          loading: false
        });
      }).catch(function() {
        _this2.setState({
          loading: false,
          error: true
        });
      });
    }
  }]);
  return RenderAfterNavermapsLoaded2;
}(import_react3.default.Component);
var cliendIdRequired = function cliendIdRequired2(props, propName, componentName) {
  (0, import_invariant2.default)(props.clientId || props.ncpClientId, "react-naver-maps: One of props 'clientId' or 'ncpClientId' should be specified in '".concat(componentName, "'."));
};
RenderAfterNavermapsLoaded.propTypes = {
  loading: import_prop_types.default.node,
  error: import_prop_types.default.node,
  clientId: cliendIdRequired,
  ncpClientId: cliendIdRequired,
  submodules: import_prop_types.default.arrayOf(import_prop_types.default.string)
};
RenderAfterNavermapsLoaded.defaultProps = {
  loading: null,
  error: null
};
export {
  Circle$1 as Circle,
  Ellipse$1 as Ellipse,
  GroundOverlay$1 as GroundOverlay,
  Marker$1 as Marker,
  NaverMap,
  Overlay$1 as Overlay,
  Polygon$1 as Polygon,
  Polyline$1 as Polyline,
  Rectangle$1 as Rectangle,
  RenderAfterNavermapsLoaded,
  loadNavermapsScript
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

load-js/index.js:
  (*! load-js v3.0.3 - Sat Sep 15 2018 18:17:56 GMT-0400 (EDT). (c) 2018 Miguel Castillo <manchagnu@gmail.com>. Licensed under MIT *)
*/
//# sourceMappingURL=react-naver-maps.js.map
