'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var hocs = require('./hocs-651c84ce.js');
var React = require('react');
var React__default = _interopDefault(React);
var debounce = _interopDefault(require('lodash.debounce'));
var recompose = require('recompose');
var invariant = _interopDefault(require('invariant'));
var PropTypes = _interopDefault(require('prop-types'));
var loadJs = _interopDefault(require('load-js'));
require('lodash.camelcase');
require('lodash.difference');
require('warning');
require('react-resize-detector');

var mapOptionKeys = ['background', 'baseTileOpacity', 'disableDoubleClickZoom', 'disableDoubleTapZoom', 'disableKineticPan', 'disableTwoFingerTapZoom', 'draggable', 'keyboardShortcuts', 'logoControl', 'logoControlOptions', 'mapDataControl', 'mapDataControlOptions', 'mapTypeControl', 'mapTypeControlOptions', 'mapTypes', 'maxBounds', 'maxZoom', 'minZoom', 'padding', 'pinchZoom', 'resizeOrigin', 'scaleControl', 'scaleControlOptions', 'scrollWheel', 'overlayZoomEffect', 'tileSpare', 'tileTransition', 'zoomControl', 'zoomControlOptions', 'zoomOrigin'];
var kvoKeys = ['mapType', 'mapTypeId', 'size', 'bounds', 'center', 'centerPoint', 'projection', 'zoom'];
var defaultKVOKeyMap = {
  defaultMapType: 'mapType',
  defaultMapTypeId: 'mapTypeId',
  defaultSize: 'size',
  defaultBounds: 'bounds',
  defaultCenter: 'center',
  defaultCenterPoint: 'centerPoint',
  defaultProjection: 'projection',
  defaultZoom: 'zoom'
};
var defaultKVOKeys = kvoKeys.map(function (key) {
  return 'default' + key[0].toUpperCase() + key.substring(1, key.length);
});
var pickMapOptions = hocs.pick(mapOptionKeys);
var pickKVOOptions = hocs.pick(kvoKeys);
var pickDefaultKVOKeys = hocs.pick(defaultKVOKeys);

var withNaverMapInstance = function withNaverMapInstance(WrappedComponent) {
  var Wrapper =
  /*#__PURE__*/
  function (_Component) {
    hocs._inherits(Wrapper, _Component);

    function Wrapper(props) {
      var _this;

      hocs._classCallCheck(this, Wrapper);

      _this = hocs._possibleConstructorReturn(this, hocs._getPrototypeOf(Wrapper).call(this, props));
      _this.lazyUpdateKVO = debounce(_this.lazyUpdateKVO, 0);
      return _this;
    }

    hocs._createClass(Wrapper, [{
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        if (this.instance) {
          this.instance.destroy();
        }
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.createMap();
        this.forceUpdate();
      } // shouldComponentUpdate(nextProps) {
      //   // child changed
      //   // kvo is not equals
      //   // option changed
      //   // handler Changed
      // }

    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        this.updateMap();
      } // componentWillUnmount() {
      //   console.log('map instance unmount');
      // }

    }, {
      key: "lazyUpdateKVO",
      value: function () {
        var _lazyUpdateKVO = hocs._asyncToGenerator(function* (_ref) {
          var zoom = _ref.zoom,
              center = _ref.center,
              bounds = _ref.bounds,
              size = _ref.size;

          // console.log('--- lazy update ---');
          if (this.break) {
            this.break = false;
            return;
          }

          var shouldUpdateZoom = zoom && this.map.getZoom() !== zoom;
          var shouldUpdateCenter = center && !this.map.getCenter().equals(center);
          var shouldUpdateBounds = bounds && !this.map.getBounds().equals(bounds);
          var shouldUpdateSize = size && !this.map.getSize().equals(size);
          var transitionOptions = this.props.transitionOptions;

          if (shouldUpdateZoom && shouldUpdateCenter) {
            // console.log('zoom, center updated');
            // onUpdateStart();
            this.updating = true;
            this.map.morph(center, zoom, transitionOptions);
          } else {
            if (shouldUpdateCenter) {
              this.updating = true;
              this.map.panTo(center, transitionOptions);
            }

            if (shouldUpdateZoom) {
              this.updating = true;
              this.map.setZoom(zoom);
            }
          }

          if (shouldUpdateSize) {
            this.map.setSize(size);
          }
        });

        return function lazyUpdateKVO(_x) {
          return _lazyUpdateKVO.apply(this, arguments);
        };
      }()
    }, {
      key: "updateMap",
      value: function updateMap() {
        var _this$props = this.props,
            zoom = _this$props.zoom,
            center = _this$props.center,
            bounds = _this$props.bounds,
            size = _this$props.size,
            mapTypeId = _this$props.mapTypeId,
            projection = _this$props.projection; // bounds, size, mapType, MapTypeId, centerPoint, projection changed
        // cancel updating state when do force update.

        if (center && center.force || bounds && bounds.force) {
          this.updating = false;
        }

        if (this.updating) {
          return;
        }

        this.lazyUpdateKVO({
          zoom: zoom,
          center: center,
          bounds: bounds,
          size: size
        }); // update kvos which is not lazy

        var shouldUpdateMapTypeId = mapTypeId && this.map.getMapTypeId() !== mapTypeId;

        if (shouldUpdateMapTypeId) {
          this.map.setMapTypeId(mapTypeId);
        }

        var shouldUpdateProjection = projection && this.map.getProjection() !== projection;

        if (shouldUpdateProjection) {
          this.map.setProjection(projection);
        }

        var mapOptions = pickMapOptions(this.props);
        this.map.setOptions(hocs._objectSpread({}, mapOptions));
      }
    }, {
      key: "createMap",
      value: function createMap() {
        var _this2 = this;

        var _this$props2 = this.props,
            navermaps = _this$props2.navermaps,
            id = _this$props2.id;
        invariant(id, 'react-naver-maps: <Map /> - props.id is required');
        var mapOptions = pickMapOptions(this.props);
        var kvoOptions = pickKVOOptions(this.props);
        var defaultKVOOptions = pickDefaultKVOKeys(this.props);

        var allMapOptions = hocs._objectSpread({}, mapOptions, kvoOptions);

        Object.keys(defaultKVOOptions).forEach(function (defaultKey) {
          // console.log(defaultKey, defaultKVOKeyMap[defaultKey], defaultKVOOptions[defaultKey])
          allMapOptions[defaultKVOKeyMap[defaultKey]] = defaultKVOOptions[defaultKey];
        });

        try {
          this.instance = new navermaps.Map(id, allMapOptions);
        } catch (e) {
          invariant(false, "react-naver-maps: <Map /> - please check <div id=#".concat(id, "> is correctly mounted"));
        } // alias


        this.map = this.instance; // clear updating state

        this.map.addListener('idle', function () {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener('zooming', function () {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener('mousedown', function () {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener('dragstart', function () {
          _this2.updating = false;
          _this2.break = true;
        });
        this.map.addListener('pinchstart', function () {
          _this2.updating = false;
          _this2.break = true;
        });
        this.props.registerEventInstance(this.map);
      }
    }, {
      key: "render",
      value: function render() {
        var _this3 = this;

        var _this$props3 = this.props,
            children = _this$props3.children,
            restProps = hocs._objectWithoutProperties(_this$props3, ["children"]);

        return React__default.createElement(WrappedComponent, restProps, this.map && React__default.Children.map(children, function (child) {
          if (child) {
            return React__default.createElement(child.type, hocs._extends({}, child.props, {
              map: _this3.map
            }));
          }

          return child;
        }));
      }
    }]);

    return Wrapper;
  }(React.Component);

  Wrapper.displayName = recompose.wrapDisplayName(WrappedComponent, 'withNaverMapInstance');
  return Wrapper;
};

function NaverMapDom(_ref) {
  var id = _ref.id,
      style = _ref.style,
      className = _ref.className,
      children = _ref.children;
  return React__default.createElement("div", {
    id: id,
    className: className,
    style: style
  }, children);
}
/**
 *  @visibleName NaverMap
 */


var ComposedMap = recompose.compose(hocs.withNavermaps, // updateFixer,
hocs.bridgeEventHandlers, hocs.injectNaverRef, withNaverMapInstance)(NaverMapDom);
/**
 * Facade for Map
 * @param {*} props 
 */

function NaverMap(props) {
  return React__default.createElement(ComposedMap, props);
}

NaverMap.propTypes = {
  id: PropTypes.string,
  events: PropTypes.arrayOf(PropTypes.string),
  style: PropTypes.object
};
NaverMap.defaultProps = {
  events: ['addLayer', 'click', 'dblclick', 'doubletap', 'drag', 'dragend', 'dragstart', 'idle', 'keydown', 'keyup', 'longtap', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'panning', 'pinch', 'pinchend', 'pinchstart', 'removeLayer', 'resize', 'rightclick', 'tap', 'tilesloaded', 'touchend', 'touchmove', 'touchstart', 'twofingertap', 'zooming', 'mapType_changed', 'mapTypeId_changed', 'size_changed', 'bounds_changed', 'center_changed', 'centerPoint_changed', 'projection_changed', 'zoom_changed'],
  id: 'react-naver-map'
};

var Overlay =
/*#__PURE__*/
function (_React$Component) {
  hocs._inherits(Overlay, _React$Component);

  function Overlay() {
    hocs._classCallCheck(this, Overlay);

    return hocs._possibleConstructorReturn(this, hocs._getPrototypeOf(Overlay).apply(this, arguments));
  }

  hocs._createClass(Overlay, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.overlay) this.overlay.setMap(null);
    }
  }, {
    key: "createOverlay",
    value: function createOverlay() {
      var _this$props = this.props,
          OverlayView = _this$props.OverlayView,
          map = _this$props.map,
          registerEventInstance = _this$props.registerEventInstance;
      var overlay = new OverlayView({
        map: map
      });
      registerEventInstance(overlay);
      return overlay;
    }
  }, {
    key: "updateOverlay",
    value: function updateOverlay(overlay) {
      var overlayOptions = this.props.pickOverlayOptions(this.props);
      overlay.setOptions(overlayOptions);
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.overlay) {
        this.overlay = this.createOverlay();
      }

      this.updateOverlay(this.overlay);
      return null;
    }
  }]);

  return Overlay;
}(React__default.Component);

var Overlay$1 = hocs.bridgeEventHandlers(Overlay);

var pickCircleOptions = hocs.pick(['center', 'radius', 'strokeWeight', 'strokeOpacity', 'strokeColor', 'strokeStyle', 'strokeLineCap', 'strokeLineJoin', 'fillColor', 'fillOpacity', 'clickable', 'visible', 'zIndex']);
/**
 * 
 * @param {*} props 
 */

function Circle(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Circle,
    pickOverlayOptions: pickCircleOptions
  }));
}

Circle.defaultProps = {
  events: ['center_changed', 'click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'radius_changed', 'visible_changed', 'zIndex_changed'],
  radius: 0,
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: '#007EEA',
  strokeStyle: 'solid',
  strokeLineCap: 'butt',
  strokeLineJoin: 'miter',
  fillColor: 'none',
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Circle.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  center: PropTypes.object.isRequired,
  radius: PropTypes.number,
  strokeWeight: PropTypes.number,
  strokeOpacity: PropTypes.number,
  strokeColor: PropTypes.string,
  strokeStyle: PropTypes.string,
  strokeLineCap: PropTypes.string,
  strokeLineJoin: PropTypes.string,
  fillColor: PropTypes.string,
  fillOpacity: PropTypes.number,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number
};
var Circle$1 = hocs.withNavermaps(Circle);

var pickEllipseOptions = hocs.pick(['bounds', 'strokeWeight', 'strokeOpacity', 'strokeColor', 'strokeStyle', 'strokeLineCap', 'strokeLineJoin', 'fillColor', 'fillOpacity', 'clickable', 'visible', 'zIndex']);
/**
 * 
 * @param {*} props 
 */

function Ellipse(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Ellipse,
    pickOverlayOptions: pickEllipseOptions
  }));
}

Ellipse.defaultProps = {
  events: ['bounds_changed', 'click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'visible_changed', 'zIndex_changed'],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: '#007EEA',
  strokeStyle: 'solid',
  strokeLineCap: 'butt',
  strokeLineJoin: 'miter',
  fillColor: 'none',
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Ellipse.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  bounds: PropTypes.object.isRequired,
  strokeWeight: PropTypes.number,
  strokeOpacity: PropTypes.number,
  strokeColor: PropTypes.string,
  strokeStyle: PropTypes.string,
  strokeLineCap: PropTypes.string,
  strokeLineJoin: PropTypes.string,
  fillColor: PropTypes.string,
  fillOpacity: PropTypes.number,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number
};
var Ellipse$1 = hocs.withNavermaps(Ellipse);

/**
 * 
 * @param {*} props 
 */

var GroundOverlay =
/*#__PURE__*/
function (_React$Component) {
  hocs._inherits(GroundOverlay, _React$Component);

  function GroundOverlay() {
    hocs._classCallCheck(this, GroundOverlay);

    return hocs._possibleConstructorReturn(this, hocs._getPrototypeOf(GroundOverlay).apply(this, arguments));
  }

  hocs._createClass(GroundOverlay, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.overlay) this.overlay.setMap(null);
    }
  }, {
    key: "createGroundOverlay",
    value: function createGroundOverlay() {
      var _this$props = this.props,
          navermaps = _this$props.navermaps,
          map = _this$props.map,
          bounds = _this$props.bounds,
          url = _this$props.url,
          clickable = _this$props.clickable,
          registerEventInstance = _this$props.registerEventInstance;
      var groundOverlay = new navermaps.GroundOverlay(url, bounds, {
        map: map,
        clickable: clickable
      });
      registerEventInstance(groundOverlay);
      return groundOverlay;
    }
  }, {
    key: "updateGroundOverlay",
    value: function updateGroundOverlay(groundOverlay) {
      var opacity = this.props.opacity;
      groundOverlay.setOpacity(opacity);
    }
  }, {
    key: "render",
    value: function render() {
      if (!this.overlay) {
        this.overlay = this.createGroundOverlay();
      }

      this.updateGroundOverlay(this.overlay);
      return null;
    }
  }]);

  return GroundOverlay;
}(React__default.Component);

GroundOverlay.defaultProps = {
  events: ['click', 'dblclick']
};
GroundOverlay.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  bounds: PropTypes.object.isRequired,
  url: PropTypes.string.isRequired,
  clickable: PropTypes.bool,
  opacity: PropTypes.number
};
var GroundOverlay$1 = recompose.compose(hocs.withNavermaps, hocs.bridgeEventHandlers)(GroundOverlay);

var pickMarkerOptions = hocs.pick(['position', 'animation', 'icon', 'shape', 'title', 'cursor', 'clickable', 'draggable', 'visible', 'zIndex']);
/**
 * 
 * @param {*} props 
 */

function Marker(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Marker,
    pickOverlayOptions: pickMarkerOptions
  }));
}

Marker.defaultProps = {
  events: ['animation_changed', 'click', 'clickable_changed', 'dblclick', 'draggable_changed', 'icon_changed', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'position_changed', 'shape_changed', 'title_changed', 'visible_changed', 'zIndex_changed'],
  title: null,
  cursor: 'pointer',
  clickable: true,
  draggable: false,
  visible: true
};
Marker.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  position: PropTypes.any.isRequired,
  animation: PropTypes.number,
  icon: PropTypes.any,
  shape: PropTypes.object,
  title: PropTypes.string,
  cursor: PropTypes.string,
  draggable: PropTypes.bool,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number
};
var Marker$1 = hocs.withNavermaps(Marker);

var pickPolygonOptions = hocs.pick(['paths', 'strokeWeight', 'strokeOpacity', 'strokeColor', 'strokeStyle', 'strokeLineCap', 'strokeLineJoin', 'fillColor', 'fillOpacity', 'clickable', 'visible', 'zIndex']);
/**
 * 
 * @param {*} props 
 */

function Polygon(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Polygon,
    pickOverlayOptions: pickPolygonOptions
  }));
}

Polygon.defaultProps = {
  events: ['click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'visible_changed', 'zIndex_changed'],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: '#007EEA',
  strokeStyle: 'solid',
  strokeLineCap: 'butt',
  strokeLineJoin: 'miter',
  fillColor: 'none',
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Polygon.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  paths: PropTypes.any.isRequired,
  strokeWeight: PropTypes.number,
  strokeOpacity: PropTypes.number,
  strokeColor: PropTypes.string,
  strokeStyle: PropTypes.string,
  strokeLineCap: PropTypes.string,
  strokeLineJoin: PropTypes.string,
  fillColor: PropTypes.string,
  fillOpacity: PropTypes.number,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number
};
var Polygon$1 = hocs.withNavermaps(Polygon);

var pickPolylineOptions = hocs.pick(['path', 'strokeWeight', 'strokeOpacity', 'strokeColor', 'strokeStyle', 'strokeLineCap', 'strokeLineJoin', 'clickable', 'visible', 'zIndex', 'startIcon', 'startIconSize', 'endIcon', 'endIconSize']);
/**
 * 
 * @param {*} props 
 */

function Polyline(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Polyline,
    pickOverlayOptions: pickPolylineOptions
  }));
}

Polyline.defaultProps = {
  events: ['click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'visible_changed', 'zIndex_changed'],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: '#007EEA',
  strokeStyle: 'solid',
  strokeLineCap: 'butt',
  strokeLineJoin: 'miter',
  clickable: false,
  visible: true,
  zIndex: 0
};
Polyline.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  path: PropTypes.any.isRequired,
  strokeWeight: PropTypes.number,
  strokeOpacity: PropTypes.number,
  strokeColor: PropTypes.string,
  strokeStyle: PropTypes.string,
  strokeLineCap: PropTypes.string,
  strokeLineJoin: PropTypes.string,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number,
  startIcon: PropTypes.number,
  startIconSize: PropTypes.number,
  endIcon: PropTypes.number,
  endIconSize: PropTypes.number
};
var Polyline$1 = hocs.withNavermaps(Polyline);

var pickRectangleOptions = hocs.pick(['bounds', 'strokeWeight', 'strokeOpacity', 'strokeColor', 'strokeStyle', 'strokeLineCap', 'strokeLineJoin', 'fillColor', 'fillOpacity', 'clickable', 'visible', 'zIndex']);
/**
 * 
 * @param {*} props 
 */

function Rectangle(props) {
  return React__default.createElement(Overlay$1, hocs._extends({}, props, {
    OverlayView: props.navermaps.Rectangle,
    pickOverlayOptions: pickRectangleOptions
  }));
}

Rectangle.defaultProps = {
  events: ['bounds_changed', 'click', 'clickable_changed', 'dblclick', 'mousedown', 'mouseout', 'mouseover', 'mouseup', 'visible_changed', 'zIndex_changed'],
  strokeWeight: 1,
  strokeOpacity: 1,
  strokeColor: '#007EEA',
  strokeStyle: 'solid',
  strokeLineCap: 'butt',
  strokeLineJoin: 'miter',
  fillColor: 'none',
  fillOpacity: 1,
  clickable: false,
  visible: true,
  zIndex: 0
};
Rectangle.propTypes = {
  events: PropTypes.arrayOf(PropTypes.string),
  bounds: PropTypes.object.isRequired,
  strokeWeight: PropTypes.number,
  strokeOpacity: PropTypes.number,
  strokeColor: PropTypes.string,
  strokeStyle: PropTypes.string,
  strokeLineCap: PropTypes.string,
  strokeLineJoin: PropTypes.string,
  fillColor: PropTypes.string,
  fillOpacity: PropTypes.number,
  clickable: PropTypes.bool,
  visible: PropTypes.bool,
  zIndex: PropTypes.number
};
var Rectangle$1 = hocs.withNavermaps(Rectangle);

var _loadNavermapsScript = function _loadNavermapsScript(_ref) {
  var clientId = _ref.clientId,
      submodules = _ref.submodules,
      ncpClientId = _ref.ncpClientId;
  invariant(clientId || ncpClientId, "clientId or ncpClientId is required"); // build naver maps v3 api url

  var requestUrl = "https://openapi.map.naver.com/openapi/v3/maps.js";

  if (clientId) {
    requestUrl += "?clientId=".concat(clientId);
  } else if (ncpClientId) {
    requestUrl += "?ncpClientId=".concat(ncpClientId);
  }

  if (submodules) {
    requestUrl += "&submodules=".concat(submodules.join(','));
  }

  return loadJs(requestUrl).then(function () {
    var navermaps = window.naver.maps;

    if (navermaps.jsContentLoaded) {
      return navermaps;
    }

    var loadingJsContent = new Promise(function (resolve) {
      navermaps.onJSContentLoaded = function () {
        resolve(navermaps);
      };
    });
    return loadingJsContent;
  });
};

var loadScriptPromise = null;

var loadNavermapsScript = function loadNavermapsScript(_ref2) {
  var clientId = _ref2.clientId,
      submodules = _ref2.submodules,
      ncpClientId = _ref2.ncpClientId;
  invariant(clientId, 'loadNavermapsScript: clientId is required');

  if (loadScriptPromise) {
    return loadScriptPromise;
  }

  loadScriptPromise = _loadNavermapsScript({
    clientId: clientId,
    ncpClientId: ncpClientId,
    submodules: submodules
  });
  return loadScriptPromise;
};

var RenderAfterNavermapsLoaded =
/*#__PURE__*/
function (_React$Component) {
  hocs._inherits(RenderAfterNavermapsLoaded, _React$Component);

  function RenderAfterNavermapsLoaded(props) {
    var _this;

    hocs._classCallCheck(this, RenderAfterNavermapsLoaded);

    _this = hocs._possibleConstructorReturn(this, hocs._getPrototypeOf(RenderAfterNavermapsLoaded).call(this, props));
    _this.state = {
      loading: true
    };
    return _this;
  }

  hocs._createClass(RenderAfterNavermapsLoaded, [{
    key: "render",
    value: function render() {
      if (this.state.loading) {
        return this.props.loading;
      }

      if (this.state.error) {
        return this.props.error;
      }

      return this.props.children;
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this2 = this;

      var _this$props = this.props,
          clientId = _this$props.clientId,
          submodules = _this$props.submodules;
      loadNavermapsScript({
        clientId: clientId,
        submodules: submodules
      }).then(function () {
        _this2.setState({
          loading: false
        });
      }).catch(function () {
        _this2.setState({
          loading: false,
          error: true
        });
      });
    }
  }]);

  return RenderAfterNavermapsLoaded;
}(React__default.Component);

var cliendIdRequired = function cliendIdRequired(props, propName, componentName) {
  invariant(props.clientId || props.ncpClientId, "react-naver-maps: One of props 'clientId' or 'ncpClientId' should be specified in '".concat(componentName, "'."));
};

RenderAfterNavermapsLoaded.propTypes = {
  loading: PropTypes.node,
  error: PropTypes.node,
  clientId: cliendIdRequired,
  ncpClientId: cliendIdRequired,
  submodules: PropTypes.arrayOf(PropTypes.string)
};
RenderAfterNavermapsLoaded.defaultProps = {
  loading: null,
  error: null
};

exports.NaverMap = NaverMap;
exports.Overlay = Overlay$1;
exports.Circle = Circle$1;
exports.Ellipse = Ellipse$1;
exports.GroundOverlay = GroundOverlay$1;
exports.Marker = Marker$1;
exports.Polygon = Polygon$1;
exports.Polyline = Polyline$1;
exports.Rectangle = Rectangle$1;
exports.RenderAfterNavermapsLoaded = RenderAfterNavermapsLoaded;
exports.loadNavermapsScript = loadNavermapsScript;
